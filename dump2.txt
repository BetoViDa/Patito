grammar PatitoParser;

options {
    tokenVocab = PatitoLexer;
}

@members {
contadorenteroglobal = 1000
contadorflotanteglobal = 2000

contadorenterotemporal = 5000
contadorflotantetemporal = 7500

contadorenterolocal = 10000
contadorflotantelocal = 12500

contadorenteroconstante = 15000
contadorflotanteconstante = 20000
contadorletreroconstante = 25000
}

programa : PROGRAM ID 
{
self.nombrefuncion = $ID.text
self.funcdir.add_funcion($ID.text,"programa")
} SEMI tiene_variables tiene_funciones INICIO cuerpo FIN
{
self.cuadruplo.add_end_Cuadruplo()   
};

tiene_variables : vars?;
tiene_funciones : funcs*;

vars: VARS (complemento_vars 
{
partes = $complemento_vars.text.split(":")  
variables_separadas = partes[0].split(",")
tipo = partes[1]

for variable in variables_separadas: 
    if tipo == "entero":
        direccion = self.contadorenteroglobal
        self.funcdir.funciones[self.nombrefuncion]["tabla"].add_var(variable,tipo,direccion)
        self.contadorenteroglobal = self.contadorenteroglobal + 1
    elif tipo == "flotante":
        direccion = self.contadorflotanteglobal
        self.funcdir.funciones[self.nombrefuncion]["tabla"].add_var(variable,tipo,direccion)
        self.contadorflotanteglobal = self.contadorflotanteglobal + 1
    else:
        raise ValueError(f"Variable no identificada")
} SEMI )+ ;

complemento_vars  : ID (COMMA ID)* COLON tipo   ;
tipo : ENTERO | FLOTANTE;

funcs : NULA ID
{
self.nombrefuncion = $ID.text
self.funcdir.add_funcion($ID.text,"nula")
} LPAREN complemento_funcs
{
argumentos = $complemento_funcs.text.split(",")  
for argumento in argumentos: 
    arg_div = argumento.split(":")
    variable = arg_div[0]
    tipo = arg_div[1]
    if tipo == "entero":
        direccion = self.contadorenterolocal
        self.funcdir.funciones[self.nombrefuncion]["tabla"].add_var(variable,tipo,direccion)
        self.contadorenterolocal = self.contadorenterolocal + 1
    elif tipo == "flotante":
        direccion = self.contadorflotantelocal
        self.funcdir.funciones[self.nombrefuncion]["tabla"].add_var(variable,tipo,direccion)
        self.contadorflotantelocal = self.contadorflotantelocal + 1
    else:
        raise ValueError(f"Variable no identificada")
} RPAREN LBRACE tiene_variables cuerpo RBRACE SEMI ;

complemento_funcs : (ID COLON tipo)? | (ID COLON tipo COMMA complemento_funcs)?;
cuerpo : LBRACE tiene_estatuto RBRACE;
tiene_estatuto : (estatuto tiene_estatuto)?;
estatuto : asigna | condicion | ciclo | llamada | imprime;

asigna : ID EQUAL expresion
{
asignar = $ID.text
asignar_dir = self.funcdir.funciones["tabla"].get_direccion(asignar)
op = self.cuadruplo.pop_operating()
op_dir = self.funcdir.funciones["tabla"].get_direccion(op)
if not op:
    op_dir = self.funcdir.funciones["tabla_constantes"].get_direccion_constante(op)
self.cuadruplo.add_assign_Cuadruplo(self.semantic["="]["codigo"],op_dir,asignar_dir)
} SEMI ;

expresion : exp complemento_expresion;
complemento_expresion : (exp_logicas exp
{
operador = self.cuadruplo.pop_operator()

op2 = self.cuadruplo.pop_operating()
op2_tipo = self.cuadruplo.pop_type()
op2_dir = self.funcdir.funciones[self.nombrefuncion]["tabla"].get_direccion(op2)
if not op2_dir:
    op2_dir = self.funcdir.funciones[self.nombrefuncion]["tabla_constantes"].get_direccion_constante(op2)

op1 = self.cuadruplo.pop_operating()
op1_tipo = self.cuadruplo.pop_type()
op1_dir = self.funcdir.funciones[self.nombrefuncion]["tabla"].get_direccion(op1)
if not op1_dir:
    op1_dir = self.funcdir.funciones[self.nombrefuncion]["tabla_constantes"].get_direccion_constante(op1)

temp = self.cuadruplo.nuevo_temp()
temp_tipo = self.semantic[operador][op1_tipo][op2_tipo]
if temp_tipo == "entero":
    direccion = self.contadorenterotemporal
    self.contadorenterotemporal = direccion + 1
elif temp_tipo == "flotante":
    direccion = self.contadorflotantetemporal
    self.contadorflotantetemporal = direccion + 1

tempadd = self.funcdir.funciones[self.nombrefuncion]["tabla"].add_var(temp,temp_tipo,direccion)
self.cuadruplo.push_operating(direccion)
self.cuadruplo.push_type(temp_tipo)

self.cuadruplo.add_Cuadruplo(self.semantic[operador]["codigo"],op1_dir,op2_dir,direccion)

} )? ;
exp_logicas : GT
{
self.cuadruplo.push_operator('>')
} | LT
{
self.cuadruplo.push_operator('<')
} | NEQ
{
self.cuadruplo.push_operator('not =')
} | DEQ
{
self.cuadruplo.push_operator('==')
} ;

exp : termino (exp_signo
{
self.cuadruplo.push_operator($exp_signo.text);
} termino 
{
operador = self.cuadruplo.pop_operator()

op2 = self.cuadruplo.pop_operating()
op2_tipo = self.cuadruplo.pop_type()
op2_dir = self.funcdir.funciones[self.nombrefuncion]["tabla"].get_direccion(op2)
if not op2_dir:
    op2_dir = self.funcdir.funciones[self.nombrefuncion]["tabla_constantes"].get_direccion_constante(op2)

op1 = self.cuadruplo.pop_operating()
op1_tipo = self.cuadruplo.pop_type()
op1_dir = self.funcdir.funciones[self.nombrefuncion]["tabla"].get_direccion(op1)
if not op1_dir:
    op1_dir = self.funcdir.funciones[self.nombrefuncion]["tabla_constantes"].get_direccion_constante(op1)

temp = self.cuadruplo.nuevo_temp()
temp_tipo = self.semantic[operador][op1_tipo][op2_tipo]
if temp_tipo == "entero":
    direccion = self.contadorenterotemporal
    self.contadorenterotemporal = direccion + 1
elif temp_tipo == "flotante":
    direccion = self.contadorflotantetemporal
    self.contadorflotantetemporal = direccion + 1

tempadd = self.funcdir.funciones[self.nombrefuncion]["tabla"].add_var(temp,temp_tipo,direccion)
self.cuadruplo.push_operating(direccion)
self.cuadruplo.push_type(temp_tipo)

self.cuadruplo.add_Cuadruplo(self.semantic[operador]["codigo"],op1_dir,op2_dir,direccion)

}
)*;
exp_signo: (PLUS | MINUS) ;

termino : factor (  term_signo
{
self.cuadruplo.push_operator($term_signo.text);
} factor 
{
operador = self.cuadruplo.pop_operator()

op2 = self.cuadruplo.pop_operating()
op2_tipo = self.cuadruplo.pop_type()
op2_dir = self.funcdir.funciones[self.nombrefuncion]["tabla"].get_direccion(op2)
if not op2_dir:
    op2_dir = self.funcdir.funciones[self.nombrefuncion]["tabla_constantes"].get_direccion_constante(op2)

op1 = self.cuadruplo.pop_operating()
op1_tipo = self.cuadruplo.pop_type()
op1_dir = self.funcdir.funciones[self.nombrefuncion]["tabla"].get_direccion(op1)
if not op1_dir:
    op1_dir = self.funcdir.funciones[self.nombrefuncion]["tabla_constantes"].get_direccion_constante(op1)

temp = self.cuadruplo.nuevo_temp()
temp_tipo = self.semantic[operador][op1_tipo][op2_tipo]
if temp_tipo == "entero":
    direccion = self.contadorenterotemporal
    self.contadorenterotemporal = direccion + 1
elif temp_tipo == "flotante":
    direccion = self.contadorflotantetemporal
    self.contadorflotantetemporal = direccion + 1

tempadd = self.funcdir.funciones[self.nombrefuncion]["tabla"].add_var(temp,temp_tipo,direccion)
self.cuadruplo.push_operating(direccion)
self.cuadruplo.push_type(temp_tipo)

self.cuadruplo.add_Cuadruplo(self.semantic[operador]["codigo"],op1_dir,op2_dir,direccion)

}
)*;
term_signo: (MUL | DIV);


factor : LPAREN expresion RPAREN | factor_operaciones
{
self.cuadruplo.push_operating($factor_operaciones.text)
op_tipo = self.funcdir.funciones[self.nombrefuncion]["tabla"].get_tipo($factor_operaciones.text)
if not op_tipo :
    op_tipo = self.funcdir.funciones[self.nombrefuncion]["tabla_constantes"].get_tipo_constante($factor_operaciones.text)
self.cuadruplo.push_type(op_tipo)
};
factor_operaciones: tiene_signo? tiene_var
{
signo = $tiene_signo.text
val = $tiene_var.text
if not val.startswith("&"):
    direccion = self.funcdir.funciones["tabla_constantes"].get_direccion_constante(val)
    signo_tipo = self.cuadruplo.pop_type()
    if signo:
        if signo == "+":
            self.funcdir.funciones[self.nombrefuncion]["tabla_constantes"].add_constante("+"+val,signo_tipo,direccion)
        else:
            self.funcdir.funciones[self.nombrefuncion]["tabla_constantes"].add_constante("-"+val,signo_tipo,direccion)
    else:
        direccion = self.funcdir.funciones["tabla_constantes"].get_direccion(val)
        self.funcdir.funciones[self.nombrefuncion]["tabla_constantes"].add_constante(val,signo_tipo,direccion)

} ;
tiene_signo :  PLUS | MINUS  ;
tiene_var : ID
{
if not self.funcdir.funciones[self.nombrefuncion]["tabla"].buscar_var($ID.text):
    raise Exception(f"Varible {$ID.text} no declarada")
} | cte ;

cte : CTE_ENTERO
{
self.cuadruplo.push_type("entero")    
} | CTE_FLOTANTE
{
self.push_type("flotante")    
} ;

condicion : SI LPAREN expresion RPAREN
{
falso = self.cuadruplo.nuevo_label()
op =self.cuadruplo.pop_operating()
self.cuadruplo.add_conditional_jump(op,falso)
self.cuadruplo.push_jump(falso)
} HAZ cuerpo complemento_cond SEMI
{
final = self.cuadruplo.pop_jump()
cuentafinal = self.cuadruplo.get_current_count()
self.cuadruplo.edit_Cuadruplo_by_label(final,cuentafinal) 
} ;

complemento_cond : (SINO
{
bypass = self.cuadruplo.nuevo_label()
self.cuadruplo.add_by_pass_jump(bypass)
salto = self.cuadruplo.pop_jump()
self.cuadruplo.push_jump(bypass)
cuentaelse = self.cuadruplo.get_current_count()
self.cuadruplo.edit_Cuadruplo_by_label(salto,cuentaelse)
} cuerpo )? ;

ciclo : MIENTRAS LPAREN expresion RPAREN HAZ
{
falso = self.cuadruplo.nuevo_label()
op = self.cuadruplo.peek_operating()
cicloInd = self.cuadruplo.get_current_count()
self.cuadruplo.add_conditional_jump(op,falso)
self.cuadruplo.push_jump(falso)
self.cuadruplo.push_jump(cicloInd)
} cuerpo SEMI
{
op = self.cuadruplo.pop_operating()
salto = self.cuadruplo.pop_jump()
self.cuadruplo.add_cycle_jump(op,salto)
cuentafinal = self.cuadruplo.get_current_count()
salto = self.cuadruplo.pop_jump()
self.cuadruplo.edit_Cuadruplo_by_label(salto,cuentafinal) 
} ;

llamada : ID LPAREN complemento_llamada RPAREN SEMI ;
complemento_llamada : (tiene_expresion)? ;
tiene_expresion : expresion | expresion COMMA tiene_expresion;

imprime : ESCRIBE LPAREN complemento_imprime RPAREN SEMI ;
complemento_imprime : expresion
{
val = self.cuadruplo.pop_operating()
add = self.funcdir.funciones[self.nombrefuncion]["tabla"].get_direccion(val)
if not add :
    add = self.funcdir.funciones[self.nombrefuncion]["tabla_constantes"].get_direccion_constante(val)
self.cuadruplo.add_print_Cuadruplo(add)
} complemento_imprime_aux | CTE_LETRERO
{
direccion = self.contadorletreroconstante
val = self.funcdir.funciones[self.nombrefuncion]["tabla_constantes"].add_constante($CTE_LETRERO,"letrero",direccion)
self.contadorletreroconstante = direccion + 1
add = self.funcdir.funciones[self.nombrefuncion]["tabla_constantes"].get_direccion_constante(direccion)
self.cuadruplo.add_print_Cuadruplo(add)
} complemento_imprime_aux;
complemento_imprime_aux : ( COMMA complemento_imprime)*;